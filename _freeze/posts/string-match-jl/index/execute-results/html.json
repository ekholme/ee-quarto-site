{
  "hash": "17dfd132247640e923aa3e414b323ba9",
  "result": {
    "markdown": "---\ntitle: String Matching in Julia\ndescription: |\n  Matching strings and benchmarking performance\ndate: '2023-06-09'\npreview: img/julia.png\nformat:\n  html:\n    code-fold: false\n---\n\nYesterday, I stumbled across this [couple-month old blog post from Josiah Parry](https://josiahparry.com/posts/2023-04-13-counting-chars/) walking through creating R, Rust, and C++ functions to compare multiple candidate strings to a reference string (his real-world application for this is geohashing, but in the demo he uses arbitrary strings).\n\nThose languages are cool and all, but what about *Julia*? The gist of his blog is that Rust is super fast. And since the whole, like raison d'etre of Julia is that it's fast, I figured I'd write a version of this in Julia as well. I'm still new-ish to Julia, so I'd love if any experts could tell me how to optimize this even further.\n\n# Load Packages and Generate Data\n\nFor this, we just need the `Random` package to set a seed and sample our strings as well as the `BenchmarkTools` package to benchmark the function performance.\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing Random\nusing BenchmarkTools\n\nRandom.seed!(0408)\n\n#function to generate some strings\nfunction make_strings(n::Int)\n    v = Vector{String}(undef, n)\n\n    letters = \"abcde\"\n    numbers = \"12345\"\n\n    for i ∈ eachindex(v)\n        x = randstring(letters, 4)\n        y = randstring(numbers, 3)\n        v[i] = x * y\n    end\n    return v\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\nmake_strings (generic function with 1 method)\n```\n:::\n:::\n\n\nThis will make a vector of length `n` where each element is a 7-character string. In each of these strings, the first 4 characters will be sampled (with replacement) from `\"abcde\"`, and the last 3 characters will be sampled (with replacement) from `\"12345\"`.\n\nNext we'll set `n` to 100,000 and generate our strings. I'll also make an arbitrary reference string to compare the candidate strings against. Note that we're not benchmarking any of this stuff -- just the comparisions that will come later.\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\nn = 100_000\n\n#returns a vector of 100k strings\nx = make_strings(n);\n\nref = \"aade124\" #making a reference string to compare against\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n\"aade124\"\n```\n:::\n:::\n\n\n# Write Comparison Functions\n\nSo now we want to compare each element of `x` to `ref`. The goal is count how many characters match until we hit the first characters that don't match. For example, if we're comparing `\"abcd123\"` to `\"abde123\"`, the result would be `2`, since the first two characters (`ab` vs `ab`) match in each, but the third characters (`c` vs `d`) don't.\n\nMy first step here is to write a function that compares 1 string to 1 string -- that is', I'm not worrying about the fact that I want to do this for all the of the elements in `x` yet -- I just want to do it for 1 element.\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\nfunction compare_strings(x::String, y::String)\n    s = 0\n    for i ∈ eachindex(x)\n        x[i] != y[i] ? break : s += 1\n    end\n    return s\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\ncompare_strings (generic function with 1 method)\n```\n:::\n:::\n\n\nThis will:\n1. Create a counter, `s` (for sum) and set it equal to 0;\n2. For each index `i` (position) in x -- recall that x and y will have the same length -- compare `x[i]` and `y[i]`;\n3. If they're not equal, `break` the loop and return `s`;\n4. If they are equal, increment `s` by one and keep going\n\nWe can check that this works by using the previous example strings:\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\ncompare_strings(\"abcd123\", \"abde123\")\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n2\n```\n:::\n:::\n\n\nNow we want to write a version of this function that accepts a vector of strings and compares each element of that vector to the reference string. The cool thing about Julia is that its [multiple dispatch](https://docs.julialang.org/en/v1/manual/methods) feature allows us to define another `compare_strings()` function that accepts different types of arguments.\n\nSo we can write the following and it's perfectly acceptable and, honestly, way better IMO than how you might have to handle this in `R` or `python`\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\nfunction compare_strings(x::Vector{String}, y::String)\n    return [compare_strings(i, y) for i in x]\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\ncompare_strings (generic function with 2 methods)\n```\n:::\n:::\n\n\nNotice that the new function has the same name (`compare_strings()`) but its `x` argument is a vector of strings rather than a single string. Then, inside the function, we just call our other method that requires `x` to be a single string. We do these calls inside of a list comprehension to iterate over all of the elements in `x`.\n\n# Benchmark\n\nNow we just run the benchmark to see how our code does\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\n@benchmark compare_strings(x, ref)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>BenchmarkTools.Trial: 5038 samples with 1 evaluation.\n Range <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-cyan-fg ansi-bold\">min</span> … <span class=\"ansi-magenta-fg\">max</span><span class=\"ansi-bright-black-fg\">):  </span><span class=\"ansi-cyan-fg ansi-bold\">880.500 μs</span> … <span class=\"ansi-magenta-fg\">  2.713 ms</span>  <span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>min … max<span class=\"ansi-bright-black-fg\">): </span>0.00% … 26.16%\n Time  <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-blue-fg ansi-bold\">median</span><span class=\"ansi-bright-black-fg\">):     </span><span class=\"ansi-blue-fg ansi-bold\">951.200 μs               </span><span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>median<span class=\"ansi-bright-black-fg\">):    </span>0.00%\n Time  <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-green-fg ansi-bold\">mean</span> ± <span class=\"ansi-green-fg\">σ</span><span class=\"ansi-bright-black-fg\">):   </span><span class=\"ansi-green-fg ansi-bold\">984.414 μs</span> ± <span class=\"ansi-green-fg\">115.531 μs</span>  <span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>mean ± σ<span class=\"ansi-bright-black-fg\">):  </span>0.87% ±  4.08%\n    ▁▆██<span class=\"ansi-blue-fg\">▄</span>▂ <span class=\"ansi-green-fg\"> </span>                                                     \n  ▂▅████<span class=\"ansi-blue-fg\">█</span>█▇<span class=\"ansi-green-fg\">▇</span>▆▅▅▄▃▃▃▃▃▃▃▃▃▃▂▂▂▂▂▂▂▂▂▂▂▂▂▁▂▁▁▂▂▂▁▁▂▂▂▂▁▂▂▂▂▂▂▂▂▂▂ ▃\n  880 μs<span class=\"ansi-bright-black-fg\">           Histogram: frequency by time</span>         1.58 ms <span class=\"ansi-bold\">&lt;</span>\n Memory estimate<span class=\"ansi-bright-black-fg\">: </span><span class=\"ansi-yellow-fg\">781.30 KiB</span>, allocs estimate<span class=\"ansi-bright-black-fg\">: </span><span class=\"ansi-yellow-fg\">2</span>.</pre>\n```\n:::\n\n:::\n:::\n\n\nObviously this isn't an apples-to-apples comparison with the code Josiah wrote -- we have different machines, different input vectors, he was calling both Rust and C++ from R, etc. But the point remains that Julia is also fast...just in case people hadn't heard :)\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}