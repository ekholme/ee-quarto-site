{
  "hash": "aece1af0eb740a1701960353b2899430",
  "result": {
    "markdown": "---\ntitle: \"Simulating Triangles?\"\ndescription: |\n  Determining whether random numbers can form a triangle using a simulation\ndate: \"2020-10-18\"\ncategories: [R, simulation, puzzle]\n---\n\n\n\nI saw this question on Reddit last night, and it seemed interesting to me & like a pretty quick blog post (which feels like all I have time for lately), so I wanted to run with it.\n\nThe question is: *Three numbers between 0 and 1 are randomly chosen. What is the probability that the 3 numbers are the lengths of the sides of a triangle?*\n\nThere's probably a mathematical way to answer this question, but I'm going to approach it using simulation. First, let's load packages and do some setup (note that we can do all of this first part in base R, but I'm loading some packages to help out with the bonus section at the end).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(ggridges)\nlibrary(eemisc)\n\nherm <- harrypotter::hp(n = 1, option = \"HermioneGranger\")\n\ntheme_set(theme_ee())\n\nopts <- options(\n  ggplot2.discrete.fill = list(\n    harrypotter::hp(n = 3, option = \"HermioneGranger\"),\n    harrypotter::hp(n = 5, option = \"Always\")\n  )\n)\n```\n:::\n\n\n## Defining the Problem\n\nOur problem is fairly straightforward. My approach is to think about it like this:\n- If we choose 3 random numbers between 0 and 1, could they correspond to the lengths of a triangle?\n- If we repeated the previous step thousands (or millions) of times, what percent of the trials would form triangles. This will approximate the actual probability.\n\nThe other piece of information that's relevant here is the requirement that, to form a triangle, the sum of the lengths of the two shorter segments must be longer than the length of the longest segment. Which makes sense intuitively if you think about what a triangle actually looks like.\n\n## Simulating & Evaluating a Single Case\n\nSimulating a single trial is very straightforward and only requires the `runif()` function, which randomly samples from a uniform distribution (note that I used to think this function meant \"run if...\" and was very confused by it). We can do this as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(0408)\nx <- runif(n = 3, min = 0, max = 1)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.009171368 0.084638904 0.618047172\n```\n:::\n:::\n\n\n\nNow that we have these random numbers, the task is to figure out whether they can serve as the lengths of a triangle. Thinking back to our previous rule, we need the sum of the two shorter numbers to be greater than the largest number. We can evaluate this by:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmin(x) + median(x) > max(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\n\nFor our first example, we see that this is false\n\n## Simulating & Evaluating Many Cases\n\nOk, great. Now that we've managed to do this once, we just need to repeat the process several times. After evaluating many repeated trials, we'll have our (approximate) probability. Here, I'm going to write a function to do simulate some numbers and then evaluate whether they could be the lengths of the sides of a triangle.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsim_func <- function() {\n  x <- runif(n = 3, min = 0, max = 1)\n  \n  min(x) + median(x) > max(x)\n}\nsim_func()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n\nAnd then the next step is to run that function several times (I'm going to go with 100,000) and then calculate the % that evaluate to TRUE.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalc_prob <- function(sims) {\n  tmp <- replicate(sims, sim_func())\n  \n  sum(tmp)/sims\n}\nset.seed(0408)\ncalc_prob(1e5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.50059\n```\n:::\n:::\n\n\n\nWe arrive at an answer of about 50%.\n\n## Bonus -- Calculating Triangle Angles\n\nNow that we've determined how to simulate a bunch of triangles by evaluating the lengths of their sides, we can go a step further and calculate all the interior angles of these triangles. To do this, I'll need to tweak my earlier function a little bit -- rather than returning TRUE/FALSE, I need it to now return each of the sides. After simulating 10,000 (potential) triangles, I'll filter for just those that actually can be triangles.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsim_sides <- function() {\n  x <- runif(n = 3)\n  \n  tmp <- tibble(a = min(x), b = median(x), c = max(x))\n  \n}\nset.seed(0408)\nsimmed_triangles <- replicate(10000, sim_sides(), simplify = FALSE) %>%\n  bind_rows() %>%\n  filter(a + b > c)\n```\n:::\n\n\n\nThe next step is to throw it back to high school geometry and the law of cosines. Using the formula below, we can calculate any angle of a triangle if we know the lengths of the three sides:\n\n$\\gamma = cos^{-1}(\\frac{a^2 + b^2 - c^2}{2ab})$\n\nwhere $\\gamma$ is the angle we're solving for, `a` and `b` are adjacent angles, and `c` is the angle opposite $\\gamma$. One other thing to keep in mind is that R will calculate these angles in radians, so I'll need to convert them to degrees (well, I don't *need* to, but I'd prefer to).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalc_angle <- function(opp, adj1, adj2) {\n  180*(acos((adj1^2 + adj2^2 - opp^2)/(2*adj1*adj2)))/pi\n}\nsimmed_angles <- simmed_triangles %>%\n  mutate(ang_a = calc_angle(a, b, c),\n         ang_b = calc_angle(b, a, c),\n         ang_c = calc_angle(c, a, b),\n         id = row_number())\n```\n:::\n\n\n\nI'm going to check to make sure that the sum of the angles equals 180 (which much be true for triangles).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimmed_angles %>%\n  mutate(is_180 = between((ang_a + ang_b + ang_c), 179.9, 180.1)) %>%\n  distinct(is_180)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 Ã— 1\n  is_180\n  <lgl> \n1 TRUE  \n```\n:::\n:::\n\n\n\nCool, so the sum of all of the angles is 180.\n\nAngle C should always be the largest angle, which means it must be >= 60. Let's do a quick check on that here.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrange(simmed_angles$ang_c)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  60.36463 179.27215\n```\n:::\n:::\n\n\n\nGreat. And let's finally plot the distribution of these angles\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimmed_angles %>%\n  select(-c(\"a\", \"b\", \"c\")) %>%\n  pivot_longer(cols = -id,\n               names_to = \"nms\",\n               values_to = \"value\") %>%\n  ggplot(aes(y = nms, x = value)) +\n  geom_density_ridges(aes(fill = nms), alpha = .8, stat = \"binline\") +\n  scale_y_discrete(labels = c(\"Angle A\", \"Angle B\", \"Angle C\")) +\n  labs(\n    x = \"Angle (in degrees)\",\n    y = NULL,\n    title = \"Distribution of Angles\"\n  ) +\n  theme(\n    legend.position = \"none\",\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n\nGreat, so we learned how to determine whether 3 random numbers could form the sides of a triangle and how to calculate the angles for those that did form a triangle.",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": null
  }
}