{
  "hash": "ee0b3aef676d9990184b588e0ac449c4",
  "result": {
    "markdown": "---\ntitle: Probability of Drawing a Full House\ndescription: |\n  Calculating the probability of drawing a full house\ndate: '2024-03-29'\nformat:\n  html:\n    code-fold: true\n    fig-height: 7\n    fig-width: 8\nexecute:\n  warning: false\ncategories:\n  - Julia\n  - Probability\n---\n\nI recently saw someone mention that they received an interview question for a DS position in which they were asked to calculate the probability of drawing a full house when drawing 5 cards from a standard 52-card deck.\n\nSo let's solve that in Julia.\n\n## Solving analytically\n\nThe function we want is `binomial(n::Integer, k::Integer)`, which returns the [binomial coefficient](https://en.wikipedia.org/wiki/Binomial_coefficient) -- the number of ways to choose `k` out of `n` items.\n\nLet's look at some examples. First, if we try 4C1 (4 choose 1), we expect to just get 4 -- there are 4 different ways to choose 1 item from a group of 4 items. \n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nbinomial(4, 1)\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n4\n```\n:::\n:::\n\n\nNow imagine we choose 2 different items from a group of 4. We expect to get 6 (assuming we don't care about order, i.e. that 1,2 is the same as 2,1):\n\n1. 1, 2\n2. 1, 3\n3. 1, 4\n4. 2, 3\n5. 2, 4\n6. 3, 4\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\nbinomial(4, 2)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n6\n```\n:::\n:::\n\n\nSo let's solve the actual problem now. A full house is 5 cards comprising 3-of-a-kind and a pair. There are 52 cards in a deck -- 4 suits comprising 13 unique values (2, 3, ..., Ace) each.\n\nThe approach here is to calculate the number of ways to get a full house and divide that by the number of ways to draw 5 cards from a deck. We can start with the number of ways to draw 5 cards from a deck (the denominator) first, since it's the most straightforward:\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\ndenom = binomial(52, 5)\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n2598960\n```\n:::\n:::\n\n\nThen let's calculate the number of ways we can get three of a kind. There are 13 different card values and 4 different suits. We need to choose 1 value with 3 different suits:\n\n- `binomial(13, 1)` gives us the number of ways to choose 1 value from 13 options (which is just 13)\n- `binomial(4, 3)` gives us the number of ways to choose 3 different suits from 4 possible options\n\nAnd then since this is probability, we multiply everything together:\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\nthree_kind = binomial(13, 1) * binomial(4, 3)\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n52\n```\n:::\n:::\n\n\nThen we do the same thing for drawing a pair. There are now 12 different card values (we can't get a pair of the value that we already drew three-of-a-kind for), and we need to choose 1 value with 2 different suits:\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\ntwo_kind = binomial(12, 1) * binomial(4, 2)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n72\n```\n:::\n:::\n\n\nAnd from here, we can estimate the probability of a full house by multiplying and dividing:\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\n(three_kind * two_kind) / denom\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n0.0014405762304921968\n```\n:::\n:::\n\n\nSo there's a 0.144% chance of drawing a full house from a typical 52-card deck.\n\n## Solving with simulation\n\nWe could also take a simulation-approach to solving this. First, let's create a deck of cards.\n\n::: {.cell execution_count=7}\n``` {.julia .cell-code}\nusing Random\nusing StatsBase\n\nRandom.seed!(0408)\n\ndeck = collect(repeat(1:13, 4))\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n52-element Vector{Int64}:\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 11\n 12\n 13\n  â‹®\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 11\n 12\n 13\n```\n:::\n:::\n\n\nThen we'll create a few functions to help us with the simulation:\n\n1. `make_hands()` will draw `n` 5-card hands from the deck;\n2. `is_full_house()` will check whether any given hand is a full house;\n3.  `count_full_house()` takes a vector of hands and counts the number of them that have a full house\n\n::: {.cell execution_count=8}\n``` {.julia .cell-code}\nfunction make_hands(deck::AbstractVector{<:Integer}, n::Int64)\n    v = Vector{Vector{Int64}}(undef, n)\n    for i in 1:n\n        v[i] = sample(deck, 5; replace=false)\n    end\n    return v\nend\n\nfunction is_full_house(hand::AbstractVector{<:Integer})\n    return extrema(values(countmap(hand))) == (2, 3)\nend\n\nfunction count_full_house(hands::Vector{Vector{Int64}})\n    s = 0\n    for i in eachindex(hands)\n        if is_full_house(hands[i])\n            s += 1\n        end\n    end\n    return s\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\ncount_full_house (generic function with 1 method)\n```\n:::\n:::\n\n\nThen from here we just run our simulation.\n\n::: {.cell execution_count=9}\n``` {.julia .cell-code}\nn = 1_000_000\n\nhands = make_hands(deck, n);\n\ncount_full_house(hands) / n\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n0.001446\n```\n:::\n:::\n\n\nAnd we see that we get roughly the same answer as we did previously.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}