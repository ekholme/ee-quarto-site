{
  "hash": "1b33a5964a56a04ee03ac2f71281a0be",
  "result": {
    "markdown": "---\ntitle: \"Scrantonicity - Part 2\"\ndescription: |\n  K means clustering with The Office dialogue\ndate: \"2020-04-16\"\ncategories: [R, The Office, Text Analysis, Clustering]\n---\n\n\n\n## Would I rather be feared or loved? Easy. Both.\n\nA few weeks ago, I did some [exploratory analyses](https://ericekholm.com/blog/office-part1/) of dialogue from The Office. That blog could easily have been a lot longer than it was, and so instead of writing some gigantic post that would have taken 30 minutes+ to read, I decided to separate it out into several different blog posts. And so here's volume 2.\n\nIn this post, I want to try using k-means clustering to identify patterns in who talks to whom in different episodes.\n\nOnce again, huge thanks to Brad Lindblad, the creator of the `{schrute}` package for R, which makes the dialogue from The Office easy to work with.\n\n### Setup\n\nAs in the previous blog, I'll be using the `{schrute}` package to get the transcripts from the show, and I'm going to limit the dialogue to the first 7 seasons of the show, which is when Michael Scott was around. I'll also use a handful of other packages for data cleaning, analysis, and visualization. Let's load all of this in and do some general setup.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(0408)\n\nlibrary(schrute) #office dialogue\nlibrary(tidyverse) #data wrangling tools\nlibrary(broom) #tidying models\nlibrary(tidytext) #tools for working with text data\nlibrary(knitr) #markdown functionality\nlibrary(kableExtra) #styling for tables\nlibrary(hrbrthemes) #ggplot themes\n\ntheme_set(theme_ipsum())\n\noffice <- theoffice %>%\n  filter(as.numeric(season) <= 7)\n```\n:::\n\n\n\n## I'm not superstitious, but I am a little stitious.\n\nNow that we have our data read in and our packages loaded, let's start with the cluster analysis. The goal here is going to be to figure out if there are certain \"types\" (clusters, groups, whatever you want to call them) of episodes. There are several frameworks we could use to go about doing this. One approach would be a mixture modeling approach (e.g. latent profile analysis, latent class analysis). I'm not doing that here because I want each episode to be an observation when we cluster, and I'm not sure we have enough episodes here to get good model fits using this approach. Instead, I'm going to use k-means clustering, which basically places observations (episodes, in this case) into one of _k_ groups (where _k_ is supplied by the user) by trying to minimize the \"distance\" between each observation and the center of the group. The algorithm iteratively assigns observations to groups, updates the center of each group, reassigns observations to groups, etc. until it reaches a stable solution.\n\nWe can also include all sorts of different variables in the k-means algorithm to serve as indicators. For this analysis, I'm going to use the number of exchanges between different characters per episode -- i.e. the number of exchanges between Michael and Jim, between Jim and Dwight, etc. -- to estimate groups. This could tell us, for instance, that one \"type\" of Office episode features lots of exchanges between Michael and Dwight, lots between Pam and Jim, and few between Pam and Michael. One consideration when we use the k-means algorithm is that, because we're looking at distance between observations, we typically want our observations to be on the same scale. Fortunately, since all of our indicators will be \"number of lines per episode,\" they're already on the same scale, so we don't need to worry about standardizing.\n\nLet's go ahead and set up our data. I'm also going to decide to only use the 5 characters who speak the most during the first 7 seasons in this analysis, otherwise the number of combinations of possible exchanges would be huge. These five characters are:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntop5_chars <- office %>%\n  count(character, sort = TRUE) %>%\n  top_n(5) %>%\n  pull(character)\n\ntop5_chars\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Michael\" \"Dwight\"  \"Jim\"     \"Pam\"     \"Andy\"   \n```\n:::\n:::\n\n\n\nOk, so our top 5 characters here are Michael, Dwight, Jim, Pam, and Andy. Since Andy doesn't join the show until season 3, I'm actually going to narrow our window of usable episodes to those in seasons 3-7. Otherwise, the clustering algorithm would likely group episodes with a focus on those in seasons 1 and 2, where Andy will obviously have 0 lines, vs episodes in later seasons.\n\nAdditionally, we want to code our changes so that Michael & Jim is the same as Jim & Michael.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncombos <- t(combn(top5_chars, 2)) %>%\n  as_tibble() %>%\n  mutate(comb = glue::glue(\"{V1}&{V2}\"),\n         comb_inv = glue::glue(\"{V2}&{V1}\"))\n\nreplace_comb <- combos$comb\n\nnames(replace_comb) <- combos$comb_inv\n\noffice_exchanges <- office %>%\n  filter(as.numeric(season) >= 3) %>%\n  mutate(char2 = lead(character)) %>% #this will tell us who the speaker is talking to\n  filter(character %in% top5_chars &\n         char2 %in% top5_chars &\n         character != char2) %>% #this filters down to just exchanges between our top 5 characters\n  mutate(exchange = glue::glue(\"{character}&{char2}\") %>%\n           str_replace_all(replace_comb)) %>% #these lines ensure that, e.g. Michael & Jim is coded the same as Jim & Michael\n  select(season, episode_name, character, char2, exchange) %>%\n  count(season, episode_name, exchange) %>%\n  pivot_wider(names_from = exchange,\n              values_from = n,\n              values_fill = list(n = 0))\n\nhead(office_exchanges)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 12\n  season episode_name         `Dwight&Andy` `Dwight&Jim` `Dwight&Pam` `Jim&Andy`\n   <int> <chr>                        <int>        <int>        <int>      <int>\n1      3 A Benihana Christma…             6           10           17         10\n2      3 Back from Vacation               1           16            6          2\n3      3 Beach Games                      8            8            3          1\n4      3 Ben Franklin                     0           14            2          0\n5      3 Branch Closing                   0            5            1          4\n6      3 Business School                  0           10            3          0\n# … with 6 more variables: `Jim&Pam` <int>, `Michael&Andy` <int>,\n#   `Michael&Dwight` <int>, `Michael&Jim` <int>, `Michael&Pam` <int>,\n#   `Pam&Andy` <int>\n```\n:::\n:::\n\n\n\nGreat -- now our data is all set up so that we know the number of lines exchanged between main characters in each episode. We can run some clustering algorithms now to see if there are patterns in these exchanges. To do this, we'll fit models testing out 1-10 clusters. We'll then look at the error for each of these models graphically and use this to choose how many clusters we want to include in our final model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclusters_fit <- tibble(\n  k = c(1:10),\n  km_fit = map(c(1:10), ~kmeans(office_exchanges %>% select(-c(1:2)), centers = .))\n) %>%\n  mutate(within_ss = map_dbl(km_fit, ~pluck(., 5)))\n\nclusters_fit %>%\n  ggplot(aes(x = k, y = within_ss)) +\n  geom_point() +\n  geom_line() +\n  labs(\n    title = \"Within Cluster Sum of Squares vs K\"\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/cluster-1.png){width=672}\n:::\n:::\n\n\n\nWe can see that error decreases as we add more clusters, and error will *always* decrease as k increases. But we can also see that the rate of decrease slows down a bit as we increase our number of clusters. Ideally, there would be a definitive bend, or \"elbow\" in this plot where the rate of decrease levels off (which is also the number of clusters we'd choose), but that's not quite the case here. It seems like there's some slight elbow-ing at 5 clusters, so let's just go ahead and choose that. Now we can look at the patterns of exchanges in each of these clusters.\n\n\n::: {.cell}\n\n```{.r .cell-code}\noffice_clustered <- augment(clusters_fit$km_fit[[5]], data = office_exchanges)\n\nclusters_long <- office_clustered %>%\n  mutate(season = as_factor(season)) %>%\n  group_by(.cluster) %>%\n  summarize_if(is.numeric, mean, na.rm = TRUE) %>%\n  ungroup() %>%\n  pivot_longer(cols = -c(\".cluster\"),\n               names_to = \"chars\",\n               values_to = \"lines\")\n\nclusters_long %>%\n  ggplot(aes(x = lines, y = chars, fill = .cluster)) +\n    geom_col() +\n    facet_wrap(~.cluster, ncol = 2, scales = \"free_y\") +\n    #scale_y_reordered() +\n    scale_fill_ipsum() +\n    theme_minimal() +\n    labs(\n      title = \"Types of Office Episodes\"\n    ) +\n    theme(\n      legend.position = \"none\"\n    )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\n\nSo, these plots show us the average number of exchanges between characters by cluster. Cluster 1 episodes seem to center around exchanges between Michael and Pam, and we also see a fair amount of exchanges between Michael & Jim, Michael & Dwight, and Jim & Pam. Cluster 2 episodes overwhelmingly feature interactions between Michael and Dwight. Cluster 3 episodes have relatively few exchanges between all of our main characters -- this probably means that there's a lot of side character action going on (recall that we didn't include exchanges between anyone other than Michael, Dwight, Jim, Pam, and Andy in our clustering algorithm). Cluster 4 episodes have a lot of Michael and Andy interactions, along with a fair number of Michael-Dwight and Jim-Pam interactions. And Cluster 5 seems to be predominantly Michael and Jim, but also a fair amount of Michael-Dwight and Dwight-Jim, which makes sense. Usually when Jim talks to Michael in the show, Dwight finds a way to intrude.\n\nOne thing to remember is that these clusters aren't necessarily balanced. As the table below shows, *most* episodes fit into Cluster 3.\n\n\n::: {.cell}\n\n```{.r .cell-code}\noffice_clustered %>%\n  count(.cluster, name = \"num_episodes\") %>%\n  kable(format = \"html\") %>%\n  kable_styling(bootstrap_options = c(\"condensed\", \"striped\", \"hover\"))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-condensed table-striped table-hover\" style=\"margin-left: auto; margin-right: auto;\">\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> .cluster </th>\n   <th style=\"text-align:right;\"> num_episodes </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> 1 </td>\n   <td style=\"text-align:right;\"> 16 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 2 </td>\n   <td style=\"text-align:right;\"> 10 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 3 </td>\n   <td style=\"text-align:right;\"> 60 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 4 </td>\n   <td style=\"text-align:right;\"> 8 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 5 </td>\n   <td style=\"text-align:right;\"> 17 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n\nAnother thing to keep in mind is that, across the all of the characters, Michael has far and away the most lines, so his interactions tend to drive this clustering. If we centered and scaled our variables, this would likely change, but we'd also lose some of the interpretability that comes with working in the raw metrics.\n\nFinally, let's just choose a random episode from each cluster to see which episodes are falling into which categories.\n\n\n::: {.cell}\n\n```{.r .cell-code}\noffice_clustered %>%\n  group_by(.cluster) %>%\n  sample_n(size = 1) %>%\n  select(.cluster, season, episode_name) %>%\n  kable(format = \"html\") %>%\n  kable_styling(bootstrap_options = c(\"hover\", \"condensed\", \"striped\"))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-hover table-condensed table-striped\" style=\"margin-left: auto; margin-right: auto;\">\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> .cluster </th>\n   <th style=\"text-align:right;\"> season </th>\n   <th style=\"text-align:left;\"> episode_name </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> 1 </td>\n   <td style=\"text-align:right;\"> 3 </td>\n   <td style=\"text-align:left;\"> Women's Appreciation </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 2 </td>\n   <td style=\"text-align:right;\"> 3 </td>\n   <td style=\"text-align:left;\"> The Coup </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 3 </td>\n   <td style=\"text-align:right;\"> 3 </td>\n   <td style=\"text-align:left;\"> Diwali </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 4 </td>\n   <td style=\"text-align:right;\"> 7 </td>\n   <td style=\"text-align:left;\"> Andy's Play </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 5 </td>\n   <td style=\"text-align:right;\"> 3 </td>\n   <td style=\"text-align:left;\"> The Merger </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n\nThat's all for now. I might do one more with some predictive modeling in the future.",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../../site_libs/kePrint-0.0.1/kePrint.js\"></script>\n<link href=\"../../site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": null
  }
}