{
  "hash": "da126ba969d29b3dbcd9ab7e7bbdcb06",
  "result": {
    "markdown": "---\ntitle: \"Riddler Express - March 20, 2020\"\ndescription: |\n  Solving a math puzzle and exploring the accumulate() function\ndate: \"2020-03-31\"\ncategories: [R, Puzzles, Coding Challenge]\n---\n\n\n\nOne of my personal goals for 2020 is to improve my proficiency doing data-y things -- mostly using R, but potentially other software as well. Typically, I've been using data from the [#TidyTuesday](https://github.com/rfordatascience/tidytuesday/blob/master/README.md) project to practice data visualization and data from [Kaggle](https://www.kaggle.com/), personal research projects, and other potentially interesting datasets to work on statistical modeling. I recently discovered [The Riddler](https://fivethirtyeight.com/tag/the-riddler/) series -- a weekly math/logic puzzle -- that seems to be a good medium for brushing up on other skills (e.g. certain types of math and programming) that may not come up as often when I do visualizations or statistics.\n\n## The Problem\n\nAnyway, this post solves the [Riddler Express puzzle from March 20, 2020](https://fivethirtyeight.com/features/how-many-sets-of-cards-can-you-find/). The problem is this:\n\n> A manager is trying to produce sales of his company’s widget, so he instructs his team to hold a sale every morning, lowering the price of the widget by 10 percent. However, he gives very specific instructions as to what should happen in the afternoon: Increase the price by 10 percent from the sale price, with the (incorrect) idea that it would return it to the original price. The team follows his instructions quite literally, lowering and then raising the price by 10 percent every day.\n\n> After N days, the manager walks through the store in the evening, horrified to see that the widgets are marked more than 50 percent off of their original price. What is the smallest possible value of N?\n\nI'll walk through a couple of ways to solve this -- first, I'll solve it algebraically, and next, I'll solve it by \"brute force\" using the `accumulate()` function from the `{purrr}` package.\n\n## Solving Algebraically\n\nSo, the first thing that strikes me when reading this is that it's essentially a compounding interest problem, except in this case the interest is negative. That is, rather than _gaining_ value exponentially over the number of compounding periods, we're _losing_ value exponentially. The formula for calculating compound interest is:\n\n\n$$A = P(1 + r)^n$$\n\n\nwhere _A_ equals the final amount, _P_ equals the principal (our initial value), _r_ equals the interest rate, and _n_ equals the number of compounding periods (the number of days in this case). We're interested in solving for the value of _n_ where our final amount, _A_, is less than .5. Our principal amount, _P_, in this case, is 1 (i.e. 100% of the value). So, our equation looks like this:\n\n\n$$.5 > ((1-1*.1)*1.1)^n$$\n\n\nThe internal logic here is that we subtract 10% from our initial value (1-1*.1) to represent the 10% decrease in price in the morning, then multiply this resulting value by 1.1 to represent the subsequent 10& increase in price in the afternoon. This simplifies to:\n\n\n$$.5 > .99^n$$\n\n\n\nFrom here, we can just solve by taking the log of each side and then dividing, which get us our answer\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- log(.5)/log(.99)\nn\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 68.96756\n```\n:::\n:::\n\n\nRounding this up (since we're dealing in full days), we can say that after **69** days, the price of the widget will be below 50% of its initial price.\n\n## Solving using `accumulate()`\n\nWe can also solve this problem using the `accumulate()` function from the `{purrr}` package, which is part of the `{tidyverse}`. Essentially, `accumulate()` will take a function, evaluate it, and then pass the result of the evaluation back into the function, evaluate it again, pass the new result back into the function, etc. This makes it useful for solving problems like this one, where the end price of the widget on the previous day is the starting price of the widget on the current day.\n\nFirst, let's load our packages. For this, we'll just use `{tidyverse}`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\nNext, let's set up a function that, if we give it the price of the widget at the beginning of the day, will calculate the price of the widget at the end of the day.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiscount_func <- function(x) {\n  (x-x*.1)*1.1\n}\n```\n:::\n\n\nAnd then let's test this function manually a few times.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiscount_func(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.99\n```\n:::\n\n```{.r .cell-code}\ndiscount_func(.99)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.9801\n```\n:::\n\n```{.r .cell-code}\ndiscount_func(.9801)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.970299\n```\n:::\n:::\n\n\n\nNow, we can use `accumulate()` to automate what we just did manually. The first argument in `accumulate()` is, in this case, each day that we want to pass into the function. In the code below, I'm testing this for days 0-3 (but coded as 1-4 because we want the start value to be 1). The second argument is the function we just wrote.\n\n\n::: {.cell}\n\n```{.r .cell-code}\naccumulate(1:4, ~discount_func(.))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.000000 0.990000 0.980100 0.970299\n```\n:::\n:::\n\n\nAnd we can see that the values returned match our manual tests above, which is good!\n\nNow, we can use `accumulate()` to make a table with the end price of the widget each day. _Note that because we want to start the widget price at 1, our first \"day\" in the table is day 0, which represents the beginning price of the widget on day 1._\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndays_tbl <- tibble(\n  day = c(0:1000),\n  end_price = accumulate(c(1:1001), ~discount_func(.))\n)\nhead(days_tbl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 2\n    day end_price\n  <int>     <dbl>\n1     0     1    \n2     1     0.99 \n3     2     0.980\n4     3     0.970\n5     4     0.961\n6     5     0.951\n```\n:::\n:::\n\n\n\nAnd then we can plot the end price over time. I've added a little bit of transparency to each point so we can more easily see the clustering/overlap.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(days_tbl, aes(x = day, y = end_price)) +\n  geom_point(alpha = .3) +\n  theme_minimal() +\n  labs(\n    title = \"End Price of Widget over Time\"\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot results-1.png){width=672}\n:::\n:::\n\n\n\nFinally, we can find the day where the end price is below .5 by filtering our table to only those where the price is less than .5 and then returning the first row.\n\n::: {.cell}\n\n```{.r .cell-code}\ndays_tbl %>%\n  filter(end_price <= .5) %>%\n  slice(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 2\n    day end_price\n  <int>     <dbl>\n1    69     0.500\n```\n:::\n:::\n\n\nAnd we can see that this matches our algebraic result -- great success!\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": null
  }
}