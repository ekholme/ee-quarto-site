{
  "hash": "3d070e3b839270683c785e5d513527ec",
  "result": {
    "markdown": "---\ntitle: Generating Data with a Given Correlation\ndescription: |\n  Using Julia to generate a dataset with a given correlation\nauthor: EE\ndate: 2022-09-8\nformat:\n  html:\n    code-fold: false\ncategories:\n  - Julia\n  - Tutorial\n  - Brief\n---\n\nThis is going to be a short one, but I saw a comment on Twitter recently about an interview question where someone was asked to generate a dataset with variables X and Y that are correlated at *r* = .8. So I figured I'd write out some code that does this as a way to practice in Julia a little bit more.\n\nFirst we load our packages\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing Statistics\nusing Distributions\nusing CairoMakie #for plotting\nusing Random #to set a seed\n\nRandom.seed!(0408)\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\nTaskLocalRNG()\n```\n:::\n:::\n\n\nThe approach here is going to be to define a covariance (correlation) matrix and a vector of means, then define a multivariate normal distribution parameterized by these things. We'll then use this distribution to generate our data.\n\nFirst we'll define $\\Sigma$, which is our covariance matrix. Since we're generating a dataset with only 2 variables, this will be a 2x2 matrix, where the diagonals will be 1 and the off-diagonals will be .8, which is the correlation we want between X and Y.\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\n#define our covariance matrix\nΣ = [[1.0, .8] [.8, 1.0]]\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n2×2 Matrix{Float64}:\n 1.0  0.8\n 0.8  1.0\n```\n:::\n:::\n\n\nThen we'll define a mean vector. This will be a 2-element vector (one for each variable), but we don't actually care what the values are here, so let's just make them 0.\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\n#define a mean vector\n#we don't actually care what these values are, though\nμ = zeros(2)\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n2-element Vector{Float64}:\n 0.0\n 0.0\n```\n:::\n:::\n\n\nNow we can define a distribution given $\\Sigma$ and $\\mu$\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\nd = Distributions.MvNormal(μ, Σ)\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\nFullNormal(\ndim: 2\nμ: [0.0, 0.0]\nΣ: [1.0 0.8; 0.8 1.0]\n)\n```\n:::\n:::\n\n\nAnd then we can draw a sample from this distribution\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\ns = rand(d, 200)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n2×200 Matrix{Float64}:\n -1.40556   0.469524  -1.19092  -0.40408   …  -0.244792  0.874835  -0.719764\n -0.595655  1.01141   -1.84189  -0.550097      0.250661  1.72269   -0.862095\n```\n:::\n:::\n\n\nTo confirm this works like expected, we can plot the sample\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\nCairoMakie.scatter(s)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n![](index_files/figure-html/cell-7-output-1.svg){}\n:::\n:::\n\n\nIt looks like a .8 correlation to me. But to do a final check, we can get the correlation matrix of our sample.\n\n::: {.cell execution_count=7}\n``` {.julia .cell-code}\n#we need to transpose the matrix from 2x200 to 200x2, hence s' instead of s\ncor(s')\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n2×2 Matrix{Float64}:\n 1.0       0.769654\n 0.769654  1.0\n```\n:::\n:::\n\n\nClose enough. Our correlation won't be *exactly* equal to .8 using this approach since we're sampling from a distribution, but there's really no difference (imo) between a .77 correlation and a .80 correlation.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}