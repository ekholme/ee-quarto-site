{
  "hash": "46d5165eb801c8a70b386b997c7a1a5c",
  "result": {
    "markdown": "---\ntitle: \"Fitting a Multiple Regression with Torch\"\ndescription: |\n  Learning torch by fitting a multiple regression model\ndate: \"2021-11-20\"\ncategories: [R, torch, regression]\n---\n\n\n\nIn this post, I want to play around with the `{torch}` package a little bit by fitting a multiple regression model \"by hand\" (sort of) using torch and the Adam optimizer.\n\nA few warnings/disclaimers right up front:\n\n- I'm using this post as a way to explore and learn how `{torch}` works. I'm by no means an expert. I'm sure there are more concise/more idiomatic ways to do these things. And if you know about them, I'd love for you to show me!\n- I don't think fitting a multiple regression (and particularly *this* multiple regression) through `{torch}` is really worthwhile. But it felt like a way to dig into the package a little bit in a way that didn't involve loading MNIST and following a canned tutorial.\n- There are lots of data cleaning/exploration steps I'm just flat out skipping here.\n\nAll of that said, if you're still with me, let's dive in.\n\n# Loading Data\n\nFor this project, I'm going to use some ultramarathon data from [#TidyTuesday](https://github.com/rfordatascience/tidytuesday) a few weeks ago. So the first step is loading that in and setting some plot options and whatnot.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(eemisc) #for ggplot theme\nlibrary(harrypotter) #for colors\nlibrary(janitor)\nlibrary(torch)\n\n\nherm <- harrypotter::hp(n = 1, option = \"HermioneGranger\")\n\nopts <- options(\n  ggplot2.discrete.fill = list(\n    harrypotter::hp(n = 2, option = \"HermioneGranger\"),\n    harrypotter::hp(n = 3, option = \"HermioneGranger\"),\n    harrypotter::hp(n = 7, option = \"Always\")\n  )\n)\n\ntheme_set(theme_ee())\n\nultra_rankings <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2021/2021-10-26/ultra_rankings.csv')\nrace <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2021/2021-10-26/race.csv')\n```\n:::\n\n\nThen, let's take a little peeksie at the data. The first dataframe, `ultra_rankings`, provides data for each runner in each race.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(ultra_rankings)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 137,803\nColumns: 8\n$ race_year_id    <dbl> 68140, 68140, 68140, 68140, 68140, 68140, 68140, 68140…\n$ rank            <dbl> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, NA, NA, NA,…\n$ runner          <chr> \"VERHEUL Jasper\", \"MOULDING JON\", \"RICHARDSON Phill\", …\n$ time            <chr> \"26H 35M 25S\", \"27H 0M 29S\", \"28H 49M 7S\", \"30H 53M 37…\n$ age             <dbl> 30, 43, 38, 55, 48, 31, 55, 40, 47, 29, 48, 47, 52, 49…\n$ gender          <chr> \"M\", \"M\", \"M\", \"W\", \"W\", \"M\", \"W\", \"W\", \"M\", \"M\", \"M\",…\n$ nationality     <chr> \"GBR\", \"GBR\", \"GBR\", \"GBR\", \"GBR\", \"GBR\", \"GBR\", \"GBR\"…\n$ time_in_seconds <dbl> 95725, 97229, 103747, 111217, 117981, 118000, 120601, …\n```\n:::\n:::\n\n\nLet's also peek at the `race` data, which provides data about races:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(race)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 1,207\nColumns: 13\n$ race_year_id   <dbl> 68140, 72496, 69855, 67856, 70469, 66887, 67851, 68241,…\n$ event          <chr> \"Peak District Ultras\", \"UTMB®\", \"Grand Raid des Pyréné…\n$ race           <chr> \"Millstone 100\", \"UTMB®\", \"Ultra Tour 160\", \"PERSENK UL…\n$ city           <chr> \"Castleton\", \"Chamonix\", \"vielle-Aure\", \"Asenovgrad\", \"…\n$ country        <chr> \"United Kingdom\", \"France\", \"France\", \"Bulgaria\", \"Turk…\n$ date           <date> 2021-09-03, 2021-08-27, 2021-08-20, 2021-08-20, 2021-0…\n$ start_time     <time> 19:00:00, 17:00:00, 05:00:00, 18:00:00, 18:00:00, 17:0…\n$ participation  <chr> \"solo\", \"Solo\", \"solo\", \"solo\", \"solo\", \"solo\", \"solo\",…\n$ distance       <dbl> 166.9, 170.7, 167.0, 164.0, 159.9, 159.9, 163.8, 163.9,…\n$ elevation_gain <dbl> 4520, 9930, 9980, 7490, 100, 9850, 5460, 4630, 6410, 31…\n$ elevation_loss <dbl> -4520, -9930, -9980, -7500, -100, -9850, -5460, -4660, …\n$ aid_stations   <dbl> 10, 11, 13, 13, 12, 15, 5, 8, 13, 23, 13, 5, 12, 15, 0,…\n$ participants   <dbl> 150, 2300, 600, 150, 0, 300, 0, 200, 120, 100, 300, 50,…\n```\n:::\n:::\n\n\n\n# Exploring Data\n\nAgain, I'm skipping this, but you should definitely do some exploration before building a model. :)\n\n\n# Modeling with Torch\n\nSo, the idea here is to use `{torch}` to \"manually\" (sort of) estimate a multiple linear regression model. The first thing I'm going to do is refine a dataframe to use in the model. There are lots of possibilities here, but I'm going to choose to estimate model that predicts the winning time of a race from the race distance, the total elevation gain, and the total elevation loss. So let's  and filter our data down to what we'll actually use in our model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nultra_mod_df <- ultra_rankings %>%\n  left_join(race, by = \"race_year_id\") %>%\n  filter(rank == 1) %>%\n  select(time_in_seconds, distance, elevation_gain, elevation_loss)\n```\n:::\n\n\n\nNext, I'm going to drop any observations with missing values on any of these variables. I'm also going to normalize the variables, because my understanding is that this matters quite a bit for optimizing via gradient descent (and it's also good practice for linear models in general).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nultra_normed <- ultra_mod_df %>%\n  drop_na() %>%\n  mutate(across(1:4, function(x) {(mean(x) - x)/sd(x)}))\n```\n:::\n\n\n\n## Creating a Dataset\n\nRight, so, now we can get into the torch-y stuff. The first step is to use the `dataset()` constructor to build a dataset. According to the [torch documentation](https://torch.mlverse.org/docs/articles/loading-data.html), this requires following a few conventions. More specifically, we need to establish an `initialize()` function, a `.getitem()` function, and a `.length()` function.\n\nBasically, these do the following:\n\n- `initialize()` creates x (predictor) and y (outcome) tensors from the data;\n- `.getitem()` provides a way to return the x and y values for an item when provided an index (or multiple indices) by the user;\n- `.length()` tells us how many observations we have in the data\n\nWe can also define helper functions within `dataset()` as well (e.g. preprocessors for our data). I'm not going to do that here (since we've already lightly preprocessed our data), but I could if I wanted.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#initializing dataset\n\nultra_dataset <- dataset(\n  \n  name = \"ultra_dataset\",\n  \n  initialize = function(df) {\n    self$x <- df %>%\n      select(-time_in_seconds) %>%\n      as.matrix() %>%\n      torch_tensor()\n    \n    self$y <- torch_tensor(df$time_in_seconds)\n    \n  },\n    \n    .getitem = function(i) {\n      x <- self$x[i, ]\n      y <- self$y[i]\n      \n      list(x, y)\n    },\n    \n    .length = function() {\n      self$y$size()[[1]]\n    }\n)\n```\n:::\n\n\n\nLet's see what this looks like. We'll create a tensor dataset from the full ultra_normed data and then return its length:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nultra_tensor_df <- ultra_dataset(ultra_normed)\n\n\nultra_len <- ultra_tensor_df$.length()\n#note that this is the same as: length(ultra_tensor_df)\n\nultra_len\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1237\n```\n:::\n:::\n\n\n\nWe can also pull out a single observation if we want, and the result will give us the values in the X tensor and the y tensor:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nultra_tensor_df$.getitem(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\ntorch_tensor\n-0.3624\n 0.2811\n-0.2866\n[ CPUFloatType{3} ]\n\n[[2]]\ntorch_tensor\n-0.809365\n[ CPUFloatType{} ]\n```\n:::\n\n```{.r .cell-code}\n#note that 1 here refers to the index of the item\n```\n:::\n\n\n\n\n\nNext, let's make train and validation datasets.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(0408)\ntrain_ids <- sample(1:ultra_len, floor(.8*ultra_len))\nvalid_ids <- setdiff(1:ultra_len, train_ids)\n\ntrn <- ultra_dataset(ultra_normed[train_ids, ])\nvld <- ultra_dataset(ultra_normed[valid_ids, ])\n```\n:::\n\n\n\nThis would be the point where we could also define a dataloader to train on batches of the data, but I'm not going to do that here because we can just train on the entire dataset at once.\n\n## Defining a Model\n\nNow, let's define our model. Again, for our learning purposes today, this is just going to be a plain old multiple regression model. To implement this in `{torch}`, we can define the model as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlin_mod <- function(x, w, b) {\n  torch_mm(w, x) + b\n}\n```\n:::\n\n\n\nIn this model, we're taking a vector of weights (or slopes), w, multiplying it by our input matrix, x, and adding our bias (or intercept). The `torch_mm()` function lets us perform this matrix multiplication.\n\nNow that we've defined this model, let's create our w and b parameters. Since this is a linear regression, each predictor in our model will have a single weight associated with it, and we'll have a single intercept for the model. We'll just use 1 as the starting value for our w parameters and 0 as the starting value for our b parameter.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#defining parameters\nnum_feats <- 3\n\nw <- torch_ones(c(1, num_feats))\nb <- torch_zeros(1)\n```\n:::\n\n\n\nNow we can do a quick test to make sure everything fits together. We're not actually training our model at this point, but I want to just run a small sample of our training data through the model (with the parameter starting values) to make sure we don't get any errors.\n\nNote that I need to transpose the X matrix for the multiplication to work.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naa <- trn$.getitem(1:10)\n\naa_x <- torch_transpose(aa[[1]], 1, 2)\n\nt_out <- lin_mod(aa_x, w, b)\n\nt_out\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntorch_tensor\n-0.2315 -0.4256 -0.7237 -0.2182 -0.2279 -0.2015 -0.2869 -0.2124 -0.5832 -0.2300\n[ CPUFloatType{1,10} ]\n```\n:::\n:::\n\n\n\nGreat! This gives us a single output for each of our input observations, which is what we want.\n\n## Training the Model\n\nNow that we have a model and can feed data into the model, let's train it.\n\nTraining the model involves using gradient descent, an optimizer, a loss function, and backpropagation to slowly tweak our parameters until they reach their optimal values (i.e. those that minimize loss). I'm not going to do a super deep dive into what all of that means, but basically in our training loop we're going to:\n\n- Run the data through the model and get predictions;\n- Measure how good our predictions are (via the loss function);\n- Compute the gradient of the loss with respect to the parameters (via the `backward()` method);\n- Tell our optimizer to update the parameters (via `optimizer$step()`);\n- Repeat a bunch of times\n\nThat's basically what the code below does. A few little extra things to point out, thought:\n\n- In addition to training the model on the training data, I'm also getting predictions on the validation data during each iteration of the training process. This won't influence the training at all, but it'll give us a look at how the model does on a holdout set of data throughout the entire process.\n- The `torch_squeeze()` function just removes an unnecessary dimension from the predictions tensors.\n- I've also created lists to track training loss, validation loss, and parameter values throughout the fitting, and these get recorded on each pass through the training loop.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#recreate our parameters with the requires_grad attribute\nw <- torch_zeros(c(1, num_feats), requires_grad = TRUE)\nb <- torch_zeros(1, requires_grad = TRUE)\n\n#put the parameters in a list\nparams <- list(w, b)\n\n#define our optimizer\noptimizer <- optim_adam(params, lr = .1)\n\n#create lists to track values during the training\nloss_tracking <- list()\nparams_tracking <- list()\nvld_loss_tracking <- list()\n\n#training loop\nfor (i in 1:1000) {\n  \n  optimizer$zero_grad()\n  \n  x <- torch_transpose(trn$x, 1, 2)\n  vld_x <- torch_transpose(vld$x, 1, 2)\n  \n  preds <- lin_mod(x, w, b)\n  vld_preds <- lin_mod(vld_x, w, b)\n  \n  preds <- torch_squeeze(preds)\n  vld_preds <- torch_squeeze(vld_preds)\n  \n  current_loss <- nnf_mse_loss(preds, trn$y)\n  vld_loss <- nnf_mse_loss(vld_preds, vld$y)\n  \n  loss_tracking[i] <- current_loss$item()\n  vld_loss_tracking[i] <- vld_loss$item()\n  params_tracking[i] <- list(c(as.numeric(params[[1]]), as.numeric(params[[2]])))\n  \n  current_loss$backward()\n  \n  optimizer$step()\n  \n}\n```\n:::\n\n\n\n## Investigating our Results\n\nCool stuff -- our model has finished training now. Let's take a look at our final parameter values. In a little while, we'll also compare these to values we get from fitting a multiple regression using the `lm()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbetas <- tibble(\n  term = c(names(ultra_normed)[2:4], \"intercept\"),\n  size = params_tracking[[1000]]\n)\n\nbetas\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 2\n  term              size\n  <chr>            <dbl>\n1 distance       -0.154 \n2 elevation_gain  0.906 \n3 elevation_loss  0.314 \n4 intercept       0.0144\n```\n:::\n:::\n\n\n\nNext, let's take a look at how the parameter values (minus the intercept) change throughout the training loop/fitting process.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndescent_tibble <- function(i, inp) {\n  tibble(\n    iter = i,\n    distance = inp[[i]][1],\n    elevation_gain = inp[[i]][2],\n    elevation_loss = inp[[i]][3]\n  )\n}\n\nparams_fitting_tbl <- map_dfr(1:1000, ~descent_tibble(.x, params_tracking)) %>%\n  pivot_longer(cols = -iter)\n\nparams_fitting_tbl %>%\n  ggplot(aes(x = iter, y = value, color = name)) +\n  geom_line() +\n  scale_color_hp_d(option = \"HermioneGranger\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n\nWe probably could have trained for fewer iterations, but it's a small dataset and a simple model, so whatever.\n\nNow, let's see what the coefficients of a \"standard\" multiple regression (fit using `lm()`) look like. This will serve as our \"ground truth\" and will tell us if our gradient descent fitting process arrived at the \"right\" coefficient values:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod_res <- lm(time_in_seconds ~ distance + elevation_gain + elevation_loss, data = ultra_normed[train_ids, ])\n\nmod_res\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = time_in_seconds ~ distance + elevation_gain + elevation_loss, \n    data = ultra_normed[train_ids, ])\n\nCoefficients:\n   (Intercept)        distance  elevation_gain  elevation_loss  \n       0.01438        -0.15403         0.90636         0.31391  \n```\n:::\n:::\n\n\n\nGood stuff! If we look back up at the coefficients from our torch model, we can see that they're (nearly) identical to those from this `lm()` model -- which is what we want.\n\nAs a final step, let's look at the loss of the model throughout the training process on both the training set and the validation set. This will give us a sense of how our model \"learns\" throughout the process.\n\nAs sort of an aside -- we'd typically look at these metrics as a way to examine overfitting, which is a big problem for neural networks and more complex models. However, we're not running a complex model. Linear models pretty much can't overfit, so this is a less useful diagnostic here. But let's take a look anyway.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#checking out loss during training\nloss_metrics <- tibble(\n  iter = 1:1000,\n  trn_loss = unlist(loss_tracking),\n  vld_loss = unlist(vld_loss_tracking)\n) %>%\n  pivot_longer(\n    cols = -iter\n  )\n\nloss_metrics %>%\n  ggplot(aes(x = iter, y = value, color = name)) +\n  geom_line() +\n  scale_color_hp_d(option = \"HermioneGranger\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n\nRight, so this is pretty much what we'd expect. Both losses drop in the first few iterations and then level off. The fact that *both* losses flatline indicates that we're not overfitting, which again is what we expect with a linear model. We also expect our validation loss to be higher than the training loss, because the model hasn't seen this data ever.\n\n## Conclusion\n\nThat's it for now. We've learned how to write a ton of code to accomplish something we can do in a single-liner call to `lm()` :)\n\nI'm planning on digging into `{torch}` more and potentially writing a few more blogs once I get into actual neural networks with image and/or text data, but that's for another day.\n\n\n\n  \n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": null
  }
}