{
  "hash": "5eda3f0b5f3bfd5fb2506186a5ceb104",
  "result": {
    "markdown": "---\ntitle: \"Dungeons and Dragons - Part 1\"\ndescription: |\n  Wrangling JSON data from an API\ndate: \"2020-12-18\"\ncategories: [R, Tutorial, API, D&D]\n---\n\n\n\nI've been playing Dungeons and Dragons 5th edition (D&D 5e) for a few years now and really enjoy it, although COVID has really hindered my opportunity to play. That said, I recently discovered a D&D 5e [API](https://www.dnd5eapi.co/), so I figured I'd do a series of blog posts analyzing D&D data from this API. In this first post, I wanted to do a quick walkthrough of how to get data from this API using R and wrangling it into a structure that's more or less conducive to later analysis. In later posts, I'll explore the data and then get into some modeling.\n\nAs something of an aside -- the API has data for character classes, spells, races, monsters, etc. I'm mostly going to focus on the monsters data, but might use some of the other data later on.\n\n## Setup\n\nFirst, I'll load the packages I need to get and wrangle the data, which is really just `{tidyverse}`, `{jsonlite}` and good old base R. I'm also adding in the base URL of the API.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(jsonlite)\n\ndnd_base <- \"https://www.dnd5eapi.co/api/monsters/\"\n```\n:::\n\n\n## Fetching Data\n\nSo, the first step here is to actually get the data from the API. Let's walk through the process here, illustrating this with a single monster (the aboleth) and then applying the process to all of the monsters.\n\nWe'll use the `fromJSON()` function to get JSON data from the API. We'll see that this gives us a pretty gnarly nested list.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexample <- fromJSON(paste0(dnd_base, \"aboleth\"))\n\nglimpse(example)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 28\n $ index                 : chr \"aboleth\"\n $ name                  : chr \"Aboleth\"\n $ size                  : chr \"Large\"\n $ type                  : chr \"aberration\"\n $ alignment             : chr \"lawful evil\"\n $ armor_class           : int 17\n $ hit_points            : int 135\n $ hit_dice              : chr \"18d10\"\n $ speed                 :List of 2\n  ..$ walk: chr \"10 ft.\"\n  ..$ swim: chr \"40 ft.\"\n $ strength              : int 21\n $ dexterity             : int 9\n $ constitution          : int 15\n $ intelligence          : int 18\n $ wisdom                : int 15\n $ charisma              : int 18\n $ proficiencies         :'data.frame':\t5 obs. of  2 variables:\n  ..$ value      : int [1:5] 6 8 6 12 10\n  ..$ proficiency:'data.frame':\t5 obs. of  3 variables:\n  .. ..$ index: chr [1:5] \"saving-throw-con\" \"saving-throw-int\" \"saving-throw-wis\" \"skill-history\" ...\n  .. ..$ name : chr [1:5] \"Saving Throw: CON\" \"Saving Throw: INT\" \"Saving Throw: WIS\" \"Skill: History\" ...\n  .. ..$ url  : chr [1:5] \"/api/proficiencies/saving-throw-con\" \"/api/proficiencies/saving-throw-int\" \"/api/proficiencies/saving-throw-wis\" \"/api/proficiencies/skill-history\" ...\n $ damage_vulnerabilities: list()\n $ damage_resistances    : list()\n $ damage_immunities     : list()\n $ condition_immunities  : list()\n $ senses                :List of 2\n  ..$ darkvision        : chr \"120 ft.\"\n  ..$ passive_perception: int 20\n $ languages             : chr \"Deep Speech, telepathy 120 ft.\"\n $ challenge_rating      : int 10\n $ xp                    : int 5900\n $ special_abilities     :'data.frame':\t3 obs. of  3 variables:\n  ..$ name: chr [1:3] \"Amphibious\" \"Mucous Cloud\" \"Probing Telepathy\"\n  ..$ desc: chr [1:3] \"The aboleth can breathe air and water.\" \"While underwater, the aboleth is surrounded by transformative mucus. A creature that touches the aboleth or tha\"| __truncated__ \"If a creature communicates telepathically with the aboleth, the aboleth learns the creature's greatest desires \"| __truncated__\n  ..$ dc  :'data.frame':\t3 obs. of  3 variables:\n  .. ..$ dc_type     :'data.frame':\t3 obs. of  3 variables:\n  .. ..$ dc_value    : int [1:3] NA 14 NA\n  .. ..$ success_type: chr [1:3] NA \"none\" NA\n $ actions               :'data.frame':\t4 obs. of  7 variables:\n  ..$ name        : chr [1:4] \"Multiattack\" \"Tentacle\" \"Tail\" \"Enslave\"\n  ..$ desc        : chr [1:4] \"The aboleth makes three tentacle attacks.\" \"Melee Weapon Attack: +9 to hit, reach 10 ft., one target. Hit: 12 (2d6 + 5) bludgeoning damage. If the target i\"| __truncated__ \"Melee Weapon Attack: +9 to hit, reach 10 ft. one target. Hit: 15 (3d6 + 5) bludgeoning damage.\" \"The aboleth targets one creature it can see within 30 ft. of it. The target must succeed on a DC 14 Wisdom savi\"| __truncated__\n  ..$ options     :'data.frame':\t4 obs. of  2 variables:\n  .. ..$ choose: int [1:4] 1 NA NA NA\n  .. ..$ from  :List of 4\n  ..$ attack_bonus: int [1:4] NA 9 9 NA\n  ..$ dc          :'data.frame':\t4 obs. of  3 variables:\n  .. ..$ dc_type     :'data.frame':\t4 obs. of  3 variables:\n  .. ..$ dc_value    : int [1:4] NA 14 NA 14\n  .. ..$ success_type: chr [1:4] NA \"none\" NA \"none\"\n  ..$ damage      :List of 4\n  .. ..$ : NULL\n  .. ..$ :'data.frame':\t2 obs. of  2 variables:\n  .. ..$ :'data.frame':\t1 obs. of  2 variables:\n  .. ..$ : NULL\n  ..$ usage       :'data.frame':\t4 obs. of  2 variables:\n  .. ..$ type : chr [1:4] NA NA NA \"per day\"\n  .. ..$ times: int [1:4] NA NA NA 3\n $ legendary_actions     :'data.frame':\t3 obs. of  4 variables:\n  ..$ name        : chr [1:3] \"Detect\" \"Tail Swipe\" \"Psychic Drain (Costs 2 Actions)\"\n  ..$ desc        : chr [1:3] \"The aboleth makes a Wisdom (Perception) check.\" \"The aboleth makes one tail attack.\" \"One creature charmed by the aboleth takes 10 (3d6) psychic damage, and the aboleth regains hit points equal to \"| __truncated__\n  ..$ attack_bonus: int [1:3] NA NA 0\n  ..$ damage      :List of 3\n  .. ..$ : NULL\n  .. ..$ : NULL\n  .. ..$ :'data.frame':\t1 obs. of  2 variables:\n $ url                   : chr \"/api/monsters/aboleth\"\n```\n:::\n:::\n\n\n\nTo clean this list up a bit, we'll use the `enframe()` function (from `{tibble}`) to convert the lists into a dataframe and then the `pivot_wider()` function to reshape this into a single-row tibble.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexample %>%\n  enframe() %>%\n  pivot_wider(names_from = name,\n              values_from = value) %>%\n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 1\nColumns: 28\n$ index                  <list> \"aboleth\"\n$ name                   <list> \"Aboleth\"\n$ size                   <list> \"Large\"\n$ type                   <list> \"aberration\"\n$ alignment              <list> \"lawful evil\"\n$ armor_class            <list> 17\n$ hit_points             <list> 135\n$ hit_dice               <list> \"18d10\"\n$ speed                  <list> [\"10 ft.\", \"40 ft.\"]\n$ strength               <list> 21\n$ dexterity              <list> 9\n$ constitution           <list> 15\n$ intelligence           <list> 18\n$ wisdom                 <list> 15\n$ charisma               <list> 18\n$ proficiencies          <list> [<data.frame[5 x 2]>]\n$ damage_vulnerabilities <list> []\n$ damage_resistances     <list> []\n$ damage_immunities      <list> []\n$ condition_immunities   <list> []\n$ senses                 <list> [\"120 ft.\", 20]\n$ languages              <list> \"Deep Speech, telepathy 120 ft.\"\n$ challenge_rating       <list> 10\n$ xp                     <list> 5900\n$ special_abilities      <list> [<data.frame[3 x 3]>]\n$ actions                <list> [<data.frame[4 x 7]>]\n$ legendary_actions      <list> [<data.frame[3 x 4]>]\n$ url                    <list> \"/api/monsters/aboleth\"\n```\n:::\n:::\n\n\n\nGreat. This is more or less the structure we want. You might notice that all of our columns are lists rather than atomic vectors -- we'll deal with that later once we get all of the data.\n\nNow that we know the basic process, we'll just apply this to all of the monsters with data available through the API. To do that, I'll write a function that executes the previous steps, get a list of all of the monsters available in the API, use `map()` to iterate the \"fetch\" function for each monster, and then bind all of the resulting rows together.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfetch_monster <- function(monster) {\n  dnd_url <- \"https://www.dnd5eapi.co/api/monsters/\"\n  \n  ret <- fromJSON(paste0(dnd_url, monster)) %>%\n    enframe() %>%\n    pivot_wider(names_from = name,\n                values_from = value)\n  \n  return(ret)\n}\n\n#this gets all of the monster indices to plug into the fetch function\nmons <- fromJSON(dnd_base)$results %>%\n  pull(index)\n\nmonster_lists <- map(mons, fetch_monster)\n\nmons_bind <- bind_rows(monster_lists)\n\nglimpse(mons_bind)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 332\nColumns: 31\n$ index                  <list> \"aboleth\", \"acolyte\", \"adult-black-dragon\", \"a…\n$ name                   <list> \"Aboleth\", \"Acolyte\", \"Adult Black Dragon\", \"A…\n$ size                   <list> \"Large\", \"Medium\", \"Huge\", \"Huge\", \"Huge\", \"Hu…\n$ type                   <list> \"aberration\", \"humanoid\", \"dragon\", \"dragon\", …\n$ alignment              <list> \"lawful evil\", \"any alignment\", \"chaotic evil\"…\n$ armor_class            <list> 17, 10, 19, 19, 18, 19, 18, 19, 19, 19, 19, 18…\n$ hit_points             <list> 135, 9, 195, 225, 172, 212, 184, 256, 207, 256…\n$ hit_dice               <list> \"18d10\", \"2d8\", \"17d12\", \"18d12\", \"15d12\", \"17…\n$ speed                  <list> [\"10 ft.\", \"40 ft.\"], [\"30 ft.\"], [\"40 ft.\", \"…\n$ strength               <list> 21, 10, 23, 25, 23, 25, 23, 27, 23, 27, 27, 22…\n$ dexterity              <list> 9, 10, 14, 10, 10, 10, 12, 14, 12, 10, 10, 10,…\n$ constitution           <list> 15, 10, 21, 23, 21, 23, 21, 25, 21, 25, 25, 22…\n$ intelligence           <list> 18, 10, 14, 16, 14, 16, 18, 16, 18, 16, 16, 8,…\n$ wisdom                 <list> 15, 14, 13, 15, 13, 15, 15, 15, 15, 13, 13, 12…\n$ charisma               <list> 18, 11, 17, 19, 17, 19, 17, 24, 17, 21, 21, 12…\n$ proficiencies          <list> [<data.frame[5 x 2]>], [<data.frame[2 x 2]>], …\n$ damage_vulnerabilities <list> [], [], [], [], [], [], [], [], [], [], [], []…\n$ damage_resistances     <list> [], [], [], [], [], [], [], [], [], [], [], []…\n$ damage_immunities      <list> [], [], \"acid\", \"lightning\", \"fire\", \"lightnin…\n$ condition_immunities   <list> [], [], [], [], [], [], [], [], [<data.frame[1…\n$ senses                 <list> [\"120 ft.\", 20], [12], [\"60 ft.\", \"120 ft.\", 2…\n$ languages              <list> \"Deep Speech, telepathy 120 ft.\", \"any one lan…\n$ challenge_rating       <list> 10, 0.25, 14, 16, 13, 15, 14, 17, 15, 17, 16, …\n$ xp                     <list> 5900, 50, 11500, 15000, 10000, 13000, 11500, 1…\n$ special_abilities      <list> [<data.frame[3 x 3]>], [<data.frame[1 x 3]>], …\n$ actions                <list> [<data.frame[4 x 7]>], [<data.frame[1 x 4]>], …\n$ legendary_actions      <list> [<data.frame[3 x 4]>], [], [<data.frame[3 x 4]…\n$ url                    <list> \"/api/monsters/aboleth\", \"/api/monsters/acolyt…\n$ subtype                <list> <NULL>, \"any race\", <NULL>, <NULL>, <NULL>, <N…\n$ reactions              <list> <NULL>, <NULL>, <NULL>, <NULL>, <NULL>, <NULL>…\n$ forms                  <list> <NULL>, <NULL>, <NULL>, <NULL>, <NULL>, <NULL>…\n```\n:::\n:::\n\n\n\nNotice that we have the same structure as in the previous example, but now with 322 rows instead of 1. Now we can take care of coercing some of these list columns into atomic vectors.\n\n## Restructuring Data\n\nOne problem here, though, is that the possible variable values for each column differ depending on the monster (for some variables). Variables like strength, hit points, challenge rating, and xp will always be a single integer value, but variables like legendary_actions can differ greatly. People who play D&D will know that normal monsters don't have any legendary actions, and so this will be NULL for those monsters. But some monsters might have 1 or 2 legendary actions, whereas big baddies like ancient dragons can have several. This same varying structure applies to columns like proficiencies, special abilities, reactions, etc. Ultimately, this means that a list column is probably the best way to represent this type of data, since lists are more flexible, whereas some columns can be represented as an atomic vector, and so we need to figure out how to address this.\n\nTo do this, we can write a couple of functions. The first, `compare_lens()` (below), will determine if the length of each element of a list is equal to whatever size we want to compare against (I've set the default to 1, which is what we want to use in this case). It then uses the `all()` function to determine if all of these comparisons are equal to TRUE, and will return a single value of TRUE if this is the case (and a single FALSE if not).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncompare_lens <- function(x, size = 1) {\n  all(map_lgl(x, ~length(unlist(.x)) == size))\n}\n```\n:::\n\n\n\nNext, we'll use the `compare_lens()` function as the test expression in another function, `cond_unlist` (or conditionally unlist), below. The idea here is if `compare_lens()` is TRUE, then we will unlist the list (simplify it to a vector) passed to the function; otherwise, we'll leave it as is (as a list). Putting these functions together, the logic is:\n\n- Determine if all elements of a list have a length equal to 1.\n- If so, turn that list into a vector.\n- If not, leave it as a list.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncond_unlist <- function(x) {\n  if (compare_lens(x) == TRUE) {\n    unlist(x)\n  } else {\n    x\n  }\n}\n```\n:::\n\n\n\nThe final step is to apply this function to all of the columns (which, recall, are lists) in our mons_bind tibble. We can do this using a combination of `mutate()` and `across()`. After doing this, we'll see that some of the columns in our data frame have been simplified to character, integer, and double vectors, whereas others remain lists (lists of lists, lists of data frames).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmons_df <- mons_bind %>%\n  mutate(across(.cols = everything(), ~cond_unlist(x = .x)))\n\nglimpse(mons_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 332\nColumns: 31\n$ index                  <chr> \"aboleth\", \"acolyte\", \"adult-black-dragon\", \"ad…\n$ name                   <chr> \"Aboleth\", \"Acolyte\", \"Adult Black Dragon\", \"Ad…\n$ size                   <chr> \"Large\", \"Medium\", \"Huge\", \"Huge\", \"Huge\", \"Hug…\n$ type                   <chr> \"aberration\", \"humanoid\", \"dragon\", \"dragon\", \"…\n$ alignment              <chr> \"lawful evil\", \"any alignment\", \"chaotic evil\",…\n$ armor_class            <int> 17, 10, 19, 19, 18, 19, 18, 19, 19, 19, 19, 18,…\n$ hit_points             <int> 135, 9, 195, 225, 172, 212, 184, 256, 207, 256,…\n$ hit_dice               <chr> \"18d10\", \"2d8\", \"17d12\", \"18d12\", \"15d12\", \"17d…\n$ speed                  <list> [\"10 ft.\", \"40 ft.\"], [\"30 ft.\"], [\"40 ft.\", \"…\n$ strength               <int> 21, 10, 23, 25, 23, 25, 23, 27, 23, 27, 27, 22,…\n$ dexterity              <int> 9, 10, 14, 10, 10, 10, 12, 14, 12, 10, 10, 10, …\n$ constitution           <int> 15, 10, 21, 23, 21, 23, 21, 25, 21, 25, 25, 22,…\n$ intelligence           <int> 18, 10, 14, 16, 14, 16, 18, 16, 18, 16, 16, 8, …\n$ wisdom                 <int> 15, 14, 13, 15, 13, 15, 15, 15, 15, 13, 13, 12,…\n$ charisma               <int> 18, 11, 17, 19, 17, 19, 17, 24, 17, 21, 21, 12,…\n$ proficiencies          <list> [<data.frame[5 x 2]>], [<data.frame[2 x 2]>], …\n$ damage_vulnerabilities <list> [], [], [], [], [], [], [], [], [], [], [], []…\n$ damage_resistances     <list> [], [], [], [], [], [], [], [], [], [], [], []…\n$ damage_immunities      <list> [], [], \"acid\", \"lightning\", \"fire\", \"lightnin…\n$ condition_immunities   <list> [], [], [], [], [], [], [], [], [<data.frame[1…\n$ senses                 <list> [\"120 ft.\", 20], [12], [\"60 ft.\", \"120 ft.\", 2…\n$ languages              <chr> \"Deep Speech, telepathy 120 ft.\", \"any one lang…\n$ challenge_rating       <dbl> 10.00, 0.25, 14.00, 16.00, 13.00, 15.00, 14.00,…\n$ xp                     <int> 5900, 50, 11500, 15000, 10000, 13000, 11500, 18…\n$ special_abilities      <list> [<data.frame[3 x 3]>], [<data.frame[1 x 3]>], …\n$ actions                <list> [<data.frame[4 x 7]>], [<data.frame[1 x 4]>], …\n$ legendary_actions      <list> [<data.frame[3 x 4]>], [], [<data.frame[3 x 4]…\n$ url                    <chr> \"/api/monsters/aboleth\", \"/api/monsters/acolyte…\n$ subtype                <list> <NULL>, \"any race\", <NULL>, <NULL>, <NULL>, <N…\n$ reactions              <list> <NULL>, <NULL>, <NULL>, <NULL>, <NULL>, <NULL>…\n$ forms                  <list> <NULL>, <NULL>, <NULL>, <NULL>, <NULL>, <NULL>…\n```\n:::\n:::\n\n\n\nAnd there we have it. Our data is now in a pretty good state for some analysis. Depending on what we're interested in doing, we could also do some additional feature engineering on the list columns, but the choices there will be contingent on the analyses we want to do.\n\nFor my next blog in this series, I'll use this data to do some exploratory analysis, which I hope to get to in the next week or so.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": null
  }
}